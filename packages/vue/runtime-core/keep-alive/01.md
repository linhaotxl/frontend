> 为了更加清楚理解源码的意义，代码的顺序做了调整  

<!-- TOC -->

- [KeepAlive 基本介绍](#keepalive-基本介绍)
- [KeepAlive 组件流程](#keepalive-组件流程)
- [KeepAlive 实现](#keepalive-实现)
    - [检测是否是 KeepAlive 组件](#检测是否是-keepalive-组件)
    - [KeepAlive 组件](#keepalive-组件)
        - [setup](#setup)
            - [禁用函数 deactivate](#禁用函数-deactivate)
            - [激活函数 activate](#激活函数-activate)
            - [卸载函数 unmount](#卸载函数-unmount)
            - [pruneCache](#prunecache)
            - [pruneCacheEntry](#prunecacheentry)
        - [render](#render)

<!-- /TOC -->

# KeepAlive 基本介绍  
`Keepalive` 就是一个普通的组件，所以它被挂载的时候，会执行 [mountComponent]() 来挂载  
这里面会向 `KeepAlive` 的作用域上注入渲染的内部方法，在之后会用到  

```typescript
const mountComponent: MountComponentFn = {
    // ...

    // 如果是 KeepAlive 的 vnode，则向作用域 ctx 上注入渲染器属性 renderer
    if (isKeepAlive(initialVNode)) {
      ;(instance.ctx as KeepAliveContext).renderer = internals
    }

    // ...
}
```  

# KeepAlive 组件流程  

当一个组件 A 是 `keep-alive` 的子节点时，它就拥有了两种状态： **激活** 和 **禁用**  
* 当 A 第一次挂载成功后，如果之后需要卸载，则不会将 A 真正卸载的，而是使 A 进入 ”禁用“ 状态  
    “禁用” 是指将 A 移动到 `keep-alive` 自身产生的一个容器(`storageContainer`)内，并执行禁用的钩子函数  
* 当 A 再次渲染时，不会将 A 再次挂载一遍，而是使 A 进入 “激活” 状态  
    “激活” 是值将 A 从 `storageContainer` 移动到真实容器中，并执行激活的钩子函数  


# KeepAlive 实现  

## 检测是否是 KeepAlive 组件  

```typescript
// 带有 __isKeepAlive 属性被视为 KeepAlive 组件
export const isKeepAlive = (vnode: VNode): boolean => (vnode.type as any).__isKeepAlive
```  

## KeepAlive 组件  

```typescript
const KeepAliveImpl = {
    name: `KeepAlive`,

    __isKeepAlive: true,

    inheritRef: true,

    props: {
        include: [String, RegExp, Array],
        exclude: [String, RegExp, Array],
        max: [String, Number]
    },

    setup(props: KeepAliveProps, { slots }: SetupContext) {
        // ...
    }
}
```  

`KeepAlive` 组件总共接受三个参数，如下  

```typescript
type MatchPattern = string | RegExp | string[] | RegExp[]

export interface KeepAliveProps {
    include?: MatchPattern
    exclude?: MatchPattern
    max?: number | string
}
```  

`include`: 需要缓存的组件名称白名单，如果是 `string` 可以用 `,` 表示多个组件  
`exclude`: 需要缓存的组件名称黑名单，如果是 `string` 可以用 `,` 表示多个组件  
`max`: 缓存组件个数的最大值，如果超出了这个值，则会根据 `LRU` 先删除再添加缓存  

### setup  

```typescript
setup(props: KeepAliveProps, { slots }: SetupContext) {
    // 缓存对象
    const cache: Cache = new Map()
    const keys: Keys = new Set()
    
    let current: VNode | null = null

    // 获取当前组件实例，即 KeepAlive 组件的实例
    const instance = getCurrentInstance()!
    const parentSuspense = instance.suspense

    // 解析渲染器方法
    const sharedContext = instance.ctx as KeepAliveContext
    const {
        renderer: {
            p: patch,
            m: move,
            um: _unmount,
            o: { createElement }
        }
    } = sharedContext

    // 创建容器节点
    const storageContainer = createElement('div')

    // 创建激活函数，重新激活时调用
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => { /* ... */ }

    // 创建禁用函数，卸载时调用
    sharedContext.deactivate = (vnode: VNode) => { /* ... */ }

    // 封装卸载函数
    function unmount(vnode: VNode) { /* ... */ }

    function pruneCache(filter?: (name: string) => boolean) { /* ... */ }

    function pruneCacheEntry(key: CacheKey) { /* ... */ }

    let pendingCacheKey: CacheKey | null = null
    const cacheSubtree = () => {
        // fix #1621, the pendingCacheKey could be 0
        if (pendingCacheKey != null) {
            cache.set(pendingCacheKey, getInnerChild(instance.subTree))
        }
    }

    // render
    return () => { /* ... */ }
}
```  

在 `KeepAlive` 的 `render` 函数中，会给组件加上 `COMPONENT_SHOULD_KEEP_ALIVE` 和 `COMPONENT_KEPT_ALIVE` 这两个 `ShapFlag`  


#### 禁用函数 deactivate  
当一个组件卸载时，会进入 [unmount]() 函数，由于组件已经被标记为 `COMPONENT_SHOULD_KEEP_ALIVE`，所以会被禁用而不是卸载  

```typescript
const unmount: UnmountFn = () => {
    /* ... */
    
    // 调用组件作用域上的 禁用方法
    if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {
        ;(parentComponent!.ctx as KeepAliveContext).deactivate(vnode)
        return
    }

    /* ... */
}
```  

接下来看具体实现  

```typescript
sharedContext.deactivate = (vnode: VNode) => {
    // 1. 获取组件实例对象
    const instance = vnode.component!
    // 2. 将禁用的 vnode 移动到 storageContainer 中
    move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense)
    // 3. 向异步队列中添加任务
    queuePostRenderEffect(() => {
        // 3.1 执行组件的 deactive 钩子函数
        if (instance.da) {
            invokeArrayFns(instance.da)
        }
        // 3.2 执行 vnode 的 onVnodeUnmounted 钩子函数
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted
        if (vnodeHook) {
            invokeVNodeHook(vnodeHook, instance.parent, vnode)
        }
        // 3.3 标记组件状态已禁用
        instance.isDeactivated = true
    }, parentSuspense)
}
```  

**禁用的钩子函数都是在异步中执行的**  

#### 激活函数 activate  
当一个组件第二次挂载，进入 [processComponent]() 函数时，由于组件已被标记为 `COMPONENT_KEPT_ALIVE`，所以会激活而不是重新挂载  

```typescript
const processComponent = ( /* ... */ ) => {
    if (n1 == null) {
        if (n2.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {
            ;(parentComponent!.ctx as KeepAliveContext).activate(
                n2,
                container,
                anchor,
                isSVG,
                optimized
            )
        } else {
            mountComponent( /* ... */ )
        }
    }
}
```  

接下来看具体实现  

```typescript
sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
    // 1. 获取组件实例
    const instance = vnode.component!
    // 2. 将 vnode 从 storageContainer 移动到真实的容器 container 中
    move(vnode, container, anchor, MoveType.ENTER, parentSuspense)
    // 3. 比较新老 vnode 是否发生了变化
    patch(
        instance.vnode,
        vnode,
        container,
        anchor,
        instance,
        parentSuspense,
        isSVG,
        optimized
    )
    // 4. 向异步队列中添加任务
    queuePostRenderEffect(() => {
        // 4.1 标记组件状态已激活
        instance.isDeactivated = false
        // 4.2 执行 active 钩子函数
        if (instance.a) {
            invokeArrayFns(instance.a)
        }
        // 4.3 执行 vnode 的 onVnodeMounted 钩子函数
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted
        if (vnodeHook) {
            invokeVNodeHook(vnodeHook, instance.parent, vnode)
        }
    }, parentSuspense)
}
```   

**激活的钩子函数都是在异步中执行的**  

#### 卸载函数 unmount  
这里会对原始的 [卸载函数]() 进行封装，之所以要封装，是因为 `vnode` 上还存在 `COMPONENT_SHOULD_KEEP_ALIVE`，所以需要删除，不删除的话是不会卸载成功的  

```typescript
// 封装卸载函数
function unmount(vnode: VNode) {
    // 重置 ShapFlag
    resetShapeFlag(vnode)
    // 调用原始的卸载函数卸载
    _unmount(vnode, instance, parentSuspense) // 这里并没有实际删除节点
}
```  


#### pruneCache  

#### pruneCacheEntry  

### render
